<!DOCTYPE html>
<html>
    <head>
        <title>Reference</title>
        <link rel="shortcut icon" href="images/favorite-icon.ico" mce_href="images/favorite-icon.ico"/>
        <link rel="stylesheet" type="text/css" href="css/innerpage.css">
	<link rel="stylesheet" type="text/css" href="css/ide.css">
        <style type="text/css">
          .funcsig { font-weight: bold };
        </style>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33659709-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>
        <div id="page-header">
	    <div id="header-content">
		<div id="header-logo">
		</div>
		<div id="header-nav-menu">
		    <ul>
			<li><a href="index.html">overview</a></li>
			<li><a href="tutorial.html">tutorial</a></li>
			<li><a href="specification.html">specification</a></li>
			<li><a class="header-nav-menu-active" href="reference.html">reference</a></li>
			<li><a href="license.html">license</a></li>
			<li><a href="about.html">about</a></li>
			<li><a href="http://www2.precog.com/learn-quirrel-level-1">play the game</a></li>
		    </ul>
		</div>
	    </div>
	    <div class="atrib-clear-left">
	    </div>
	</div>
	<div id="page-holder">
	    <div id="page-body">
		<div id="page-side-bar">
		    <div id="side-bar-logo">
		    </div>
		    <!--
		    <div id="side-bar-navigation">
			<h1>overview</h1>
			<ul>
			    <li><a href="#gettingstarted-link">getting started</a></li>
			    <li><a href="#examples-link">examples</a></li>
			    <li><a href="#download-link">download</a></li>
			</ul>
		    </div>
		    -->
		</div>
		<div id="page-body-content">
		    <div id="page-body-text">
			<div id="page-body-header">
			    <h1>Reference</h1>
			    <h2>Syntax, operators and functions of the Quirrel language</h2>
			    <h3>Highlights</h3>
			    <ul>
			    	<li>Set-oriented data manipulation</li>
    				<li>Powerful built-in operations and functions</li>
    				<li>User-definable functions to abstract out common functionality</li>
			    </ul>
			</div>
			<div id="page-body-section">
			        <div class="page-body-column-wide">
			          <h1 id="gettingstarted-link">Getting Started</h1>
                                  <p>The <a href="tutorial.html">tutorial</a> is the best way to learn more about Quirrel. It walks you through all the concepts in Quirrel. This page provides a concise reference of language features, operators and functions. For more detail, you may want to check out the <a href="specification.html">language specification</a>.</p>
			          <h1>Data In Quirrel</h1>
                                  <p>Quirrel has native support for JSON. You can create strings, numbers, booleans, arrays, and objects just like you do in JavaScript.
				    Additionally, Quirrel is set-oriented, which means all data are represented as sets of JSON values (surrounded by "[]"). For example:</p>
				    <div class="body-code">
			      <p>{name: "John", age: 29, gender: "male"}
[{name: "John", age: 29, gender: "male"}]

true
[true]

"hello world"
["hello world"]</p>
				    </div>
                            <p>Note that single values are represented as single-element sets.</p>

                            <h1>Function Reference Table Of Contents</h1>

                            <p><a href = "#operator">Operator Reference</a></p>
                            <p><a href = "#standard">Standard Function Reference</a></p>
                            <p><a href = "#statistics">Statistics Function Reference</a></p>
                            <p><a href = "#math">Math Function Reference</a></p>
                            <p><a href = "#string">String Function Reference</a></p>
                            <p><a href = "#datetime">DateTime Function Reference</a></p>
                            <p><a href = "#type">Type Function Reference</a></p>

                            <a name = "operator"></a>
                            <h1>Operator Reference</h1>
                            <ul>
                              <li><p class="funcsig">new arg</p><p>Produces a copy of the given set with a fresh set of identities (for use in self-joins)</p></li>
                              <li><p class="funcsig">arg1 + arg2</p><p>Numeric addition</p></li>
                              <li><p class="funcsig">arg1 - arg2</p><p>Numeric subtraction</p></li>
                              <li><p class="funcsig">arg1 * arg2</p><p>Numeric multiplication</p></li>
                              <li><p class="funcsig">arg1 / arg2</p><p>Numeric division</p></li>
							  <li><p class="funcsig">arg1 ^ arg2</p><p>Numeric exponentiation</p></li>
                              <li><p class="funcsig">arg1 &lt; arg2</p><p>Numeric less-than comparison</p></li>
                              <li><p class="funcsig">arg1 &lt;= arg2</p><p>Numeric less-than-equal comparison</p></li>
                              <li><p class="funcsig">arg1 &gt; arg2</p><p>Numeric greater-than comparison</p></li>
                              <li><p class="funcsig">arg1 &gt;= arg2</p><p>Numeric greater-than-equal comparison</p></li>
                              <li><p class="funcsig">arg1 = arg2</p><p>Equality comparison</p></li>
                              <li><p class="funcsig">arg1 != arg2</p><p>Negated equality comparison</p></li>
                              <li><p class="funcsig">arg1 &amp; arg2</p><p>Boolean conjunction</p></li>
                              <li><p class="funcsig">arg1 | arg2</p><p>Boolean disjunction</p></li>
                              <li><p class="funcsig">! arg</p><p>Boolean complementation</p></li>
                              <li><p class="funcsig">neg arg</p><p>Numeric negation</p></li>
                              <li><p class="funcsig">arg1 ~ arg2 arg3</p><p>Set relation (for use in cross-set joins)</p></li>
                              <li><p class="funcsig">arg1 union arg2</p><p>Set union</p></li>
                              <li><p class="funcsig">arg1 intersect arg2</p><p>Set intersection</p></li>
                              <li><p class="funcsig">arg1 difference arg2</p><p>Set difference. Returns the events contained in arg1 which are not contained in arg2.</p></li>
                            </ul>

                            <a name = "standard"></a>
                            <h1>Standard Function Reference</h1>
                            <ul>
                              <li><p class="funcsig">count (s : Any): Int</p>
                              <p>Takes a single set and returns its size.</p></li>                              
                              
                              <li><p class="funcsig">distinct (s : Any): Any</p>
                               <p>Takes a single set and returns a set of the distinct (unique) values.</p></li>
							               <li><p class="funcsig">exists (s : Boolean): boolean</p>
                               <p>Takes a set of booleans and returns a single boolean: returns true if the given set of booleans contains at least one true value, returns false otherwise.</p></li>
							               <li><p class="funcsig"> flatten(arr: Array) : set</p>
                               <p>Takes a set of arrays and flattens them into a set where each value of the original array becomes an independent record in the resulting set.</p></li>   
                                <li><p class="funcsig">forall (s : Boolean): boolean</p>
                               <p>Takes a set of booleans and returns a single boolean: returns true if the given set of booleans contains all true values, returns false otherwise.</p></li>
                              
                              <li><p class="funcsig">geometricMean (n : Numeric): Numeric</p>
                                <p>Takes a single set and returns its geometric mean.</p></li>
                              
                              <li><p class="funcsig">load (s : String): Any</p>
                                <p>Takes a single string path and returns the set of events in the data store which correspond to the path in question.</p></li>
                              
                              <li><p class="funcsig">max (n : Numeric): Numeric</p>
                                <p>Takes a single set of numeric events and returns the maximum value among all the events.</p></li>
							  
							  <li><p class="funcsig">maxTime(times: <em>DateTime</em>): <em>DateTime</em></p>
                                <p>Takes a set of <em>DateTime</em> values and returns the maximum.</p></li>
                              
                              <li><p class="funcsig">mean (n : Numeric): Numeric</p>
                                <p>Takes a single set of numeric events and returns the arithmetic mean of all the values.</p></li>
                              
                              <li><p class="funcsig">min (n : Numeric): Numeric</p>
                                <p>Takes a single set of numeric events and returns the minimum of all the values.</p></li>
                              
							   <li><p class="funcsig">minTime(times: <em>DateTime</em>): <em>DateTime</em></p>
                                <p>Takes a set of <em>DateTime</em> values and returns the minimum.</p></li>
							   
                              <li><p class="funcsig">stdDev (n : Numeric): Numeric</p>
                                <p>Takes a single set of numeric events and returns the standard deviation from the arithmetic mean of all the values.</p></li>
                              
                              <li><p class="funcsig">sum (n : Numeric): Numeric</p>
                                <p>Takes a single set of numeric events and returns the sum of all the values.</p></li>
                                
                              <li><p class="funcsig">sumSq (n : Numeric): Numeric</p>
                               <p>Takes a single set and returns the sum of the square of each value.</p></li>                             
                               
                              <li><p class="funcsig">variance (n : Numeric): Numeric</p>
                                <p>Takes a single set and returns its population variance.</p></li>
                            </ul>
							

                            <a name = "statistics"></a>
                            <h1>Statistics Function Reference</h1>
                            <ul>
                              <li><p class="funcsig">std::stats::corr (n1 : Numeric, n2 : Numeric): Numeric</p>
                                <p>Takes two sets and returns the correlation coefficient of the matched pairs of numbers.</p></li>                              

                              <li><p class="funcsig">std::stats::cov (n1 : Numeric, n2 : Numeric): Numeric</p>
                                <p>Takes two sets and returns the population covariance of the matched pairs of numbers.</p></li>
							  
							   <li><p class="funcsig">std::stats::kMedians(data: Any, k: Numeric): Object (n1 : Numeric, n2 : Numeric): Numeric</p>
                                <p>Takes two sets. The first is a set of data on which a k-medians clustering algorithm will be run. The second is a numeric value k, which represents the number of cluster centroids that will be computed. The result is an object of the form: {"model1": {"cluster1": Any, "cluster2": Any, ...}, "model2": {"cluster1": Any, ...}, ...}. There will be one model for each schema present in the data. The values in the cluster fields represent the centroid of the cluster, inserted into the original data schema.</p></li>
							   
							    <li><p class="funcsig">std::stats::assignClusters( data: Any, models: Object): Object</p>
                                <p>Takes two sets. The first is a set of data from which the result will be assigned. The second is a set of models that must be of the form: {"model1": {"cluster1": Any, "cluster2": Any, ...}, "model2": {"cluster1": Any, ...}, ...}. A single object of the form {model1: {clusterId : "cluster1", clusterCenter:  Any }, {model1: {clusterId : "cluster2", clusterCenter:  Any} , etc. will be returned for each model whose schema is contained in the row's schema. For example, if the schema for model2 isn't included in the row's schema, while the schemas for model1 and model3 are, the result for a given row will be something like: {"model1": {clusterId" :  "cluster7", clusterCenter: { x : 3012, y : 13 },  "model3": {clusterId" :  "cluster12", clusterCenter: { x : 1267, z : 294 }.</p></li>

                              <li><p class="funcsig">std:stats::linearRegression(n1: Numeric, data: Any): Object</p>
                                <p>Takes two sets: the first is the dependent variable and the second contains all the independent variables. Each schema in the data generates a field ("Model1", "Model2", etc.) in the result object. Each of these fields contains an array of size two. The first element of the array contains the coefficients of the model, inserted into the original schema. The second element of the array is the constant term. For example, if the original data contains two schema: {"foo": Numeric, "bar": Numeric} and {"foo": Numeric}, the resulting object would have the form: {"Model1": [{"foo": Numeric, "bar", Numeric}, Numeric], "Model2": [{"foo": Numeric}, Numeric]}. </p></li>                              

                              <li><p class="funcsig">std::stats::logisticRegression(n1: Numeric, data: Any): Object</p>
                                <p>Takes two sets: the first is the dependent variable and the second contains all the independent variables. The dependent variable must have numeric value 0 or value 1. Each schema in the data generates a field ("Model1", "Model2", etc.) in the resulting object. Each of these fields contains an array of size two. The first element of the array contains the coefficients of the model, inserted into the original schema. The second element of the array contains the constant term. For example, if the original data contains two schema: {"foo": Numeric, "bar": Numeric} and {"foo": Numeric}, the resulting object would have the form: {"Model1": [{"foo": Numeric, "bar", Numeric}, Numeric], "Model2": [{"foo": Numeric}, Numeric]}. </p></li>                              
								
								<li><p class="funcsig">std::stats::predictLinear(data: Any, models: Object): Object</p>
                                <p>Takes two sets. The first is a set of data from which the result will be predicted. The second is a set of models that must be of the form: {"Model1": [Any, Numeric], "Model2": [Any, Numeric], . . .}. Consider a row of data. A single numeric value will be returned for each model whose schema is contained in the row's schema. For example, if the schema for Model2 isn't included in the row's schema, while the schemas for Model1 and Model3 are, the result for a given row will be of the form: {"Model1": Numeric, "Model3": Numeric}. </p></li>                              

								<li><p class="funcsig">std::stats::predictLogistic(data: Any, models: Object): Object</p>
                                <p>Identitical to predictLinear, except that the resulting numerics will be values between 0 and 1. </p></li>                              

                              <li><p class="funcsig">std::stats::rank(s : Any): Numeric</p>
                                <p>Takes a single set, and returns a set of numbers whose ordering corresponds to the lexical ordering of the original set, starting from 0. If the values of multiple events in the original set compare as equal (ignoring event identities) they will have the same rank value. There may be discontinuities in the sequence of numbers returned.</p></li>                              

                              <li><p class="funcsig">std::stats::denseRank(s: Any): Numeric</p>
                                <p>Takes a single set, and returns a set of numbers whose ordering corresponds to the lexical ordering of the original set, starting from 0. If the values of multiple events in the original set compare as equal (ignoring event identities) they will have the same rank value. There will be no discontinuities in the sequence of numbers returned.</p></li>                              
								
						      <li><p class="funcsig">std::stats::indexedRank(s: Any): Numeric</p>
                                <p>Takes a single set, and returns a set of numbers whose ordering corresponds to the lexical ordering of the original set, but where values that compare as equal (ignoring event identities) are each assigned distinct rank values. The order of rank values within a group of equal event values is arbitrary, but you are guaranteed that rank values respect the lexical ordering and that there will be no discontinuities in the sequence of numbers returned.</p></li>                              
							</ul>
							
                            <a name = "math"></a>
                            <h1> Math Function Reference</h1>
                            <ul>
                              <li><p class="funcsig">std::math::abs (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each absolute value.</p></li>

                              <li><p class="funcsig">std::math::acos (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each arccosine.</p></li>

                              <li><p class="funcsig">std::math::asin (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each arcsine.</p></li>
                                
                              <li><p class="funcsig">std::math::atan (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each arctangent.</p></li>

                              <li><p class="funcsig">std::math::atan2 (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the angle theta from the conversion of each pair of rectangular coordinates to polar coordinates.</p></li>

                              <li><p class="funcsig">std::math::cbrt (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each cube root.</p></li>

                              <li><p class="funcsig">std::math::ceil (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each ceiling.</p></li>

                              <li><p class="funcsig">std::math::copySign (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns the first value with the sign of the second value.</p></li>

                              <li><p class="funcsig">std::math::cos (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each cosine.</p></li>

                              <li><p class="funcsig">std::math::cosh (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each hyperbolic cosine.</p></li>

                              <li><p class="funcsig">std::math::exp (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of Euler's number (e) raised to each value.</p></li>

                              <li><p class="funcsig">std::math::floor (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each floor.</p></li>

                              <li><p class="funcsig">std::math::hypot (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the square root of the sum of the square of each pair.</p></li>

                              <li><p class="funcsig">std::math::IEEEremainder (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the remainder operation computed on the two values, as prescribed by the IEEE 754 standard.</p></li>

                              <li><p class="funcsig">std::math::log (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each natural log.</p></li>

                              <li><p class="funcsig">std::math::log10 (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each log in base 10.</p></li>

                              <li><p class="funcsig">std::math::minOf (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the minimum of each pair.</p></li>

                              <li><p class="funcsig">std::math::maxOf (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the maximum of each pair.</p></li>
							  
							  <li><p class="funcsig">std::math::parseNum (s: String): Numeric</p>
                                <p>Converts the given string to a numeric value if possible (otherwise the result is undefined).</p></li>

                              <li><p class="funcsig">std::math::pow (n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and returns a set of the first value raised to the power of the second value.</p></li>

                              <li><p class="funcsig">std::math::roundTo(n1: Numeric, n2: Numeric): Double</p>
                                <p>Takes two sets of numeric events and rounds the first to the number of decimals specified in the second. A negative number in the 2nd field indicates decimals to the right. So, roundTo(1234, neg 2) would return 1200.</p></li>
							  
							  <li><p class="funcsig">std::math::round (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each value rounded.</p></li>

                              <li><p class="funcsig">std::math::sin (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each sine.</p></li>

                              <li><p class="funcsig">std::math::signum (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each signum. 1.0 if the argument is greater than zero. -1.0 if the argument is less than zero.</p></li>

                              <li><p class="funcsig">std::math::sinh (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each hyperbolic sine.</p></li>

                              <li><p class="funcsig">std::math::sqrt (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each square root.</p></li>

                              <li><p class="funcsig">std::math::tan (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each tangent.</p></li>

                              <li><p class="funcsig">std::math::tanh (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of each hyperbolic tangent.</p></li>

                              <li><p class="funcsig">std::math::toDegrees (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events (in Radians) and returns a set of each value in degrees.</p></li>

                              <li><p class="funcsig">std::math::toRadians (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events (in degrees) and returns a set of each value in Radians.</p></li>

                              <li><p class="funcsig">std::math::ulp (n: Numeric): Double</p>
                                <p>Takes a single set of numeric events and returns a set of the size of each unit in the last place.</p></li>
                            </ul>

                            <a name = "string"></a>
                            <h1>String Function Reference</h1>
                            <ul>

                              <li><p class="funcsig">std::string::codePointAt (s: String, n: Numeric): Int</p>
                                <p>Takes a single set of string events and a set of numeric events. Returns the character (Unicode code point) at the specified index.</p></li>

                              <li><p class="funcsig">std::string::codePointBefore (s: String, n: Numeric): Int</p>
                                <p>Takes a single set of string events and a set of numeric events. Returns the character (Unicode code point) before the specified index.</p></li>

                              <li><p class="funcsig">std::string::concat (s1: String, s2: String): String</p>
                                <p>Takes two sets of string events and returns the concatenation of the two strings.</p></li>
							  
							  <li><p class="funcsig">std::string::dropLeft:(s: String, n: Numeric): String</p>
                                <p>Takes a set of string events and returns a new substring of the first string, removing the first n letters from s. If there are less than n letters in s, then the empty string is returned.</p></li>
							  
							  <li><p class="funcsig">std::string::dropRight(s: String, n: Numeric): String</p>
                                <p>Takes a set of string events and returns a new substring of the first string, removing the last n letters from s. If there are less than n letters in s, then the empty string is returned.</p></li>

                              <li><p class="funcsig">std::string::endsWith (s1: String, s2: String): Boolean</p>
                                <p>Takes two sets of string events and returns a set of true or false. True if and only if the first string ends with the suffix specified by the second string.</p></li>

                              <li><p class="funcsig">std::string::equals (s1: String, s2: String): Boolean</p>
                                <p>Takes two sets of string events and returns a set of true or false. True if and only if the two strings are equivalent.</p></li>

                              <li><p class="funcsig">std::string::equalsIgnoreCase (s1: String, s2: String): Boolean</p>
                                <p>Takes two sets of string events and returns a set of true or false. True if and only if the two strings are equivalent, ignoring case considerations.</p></li>

                              <li><p class="funcsig">std::string::indexOf (s1: String, s2: String): Int</p>
                                <p>Takes two sets of string events and returns the index in the first string of the first occurrence of the substring specified by the second string.</p></li>

                              <li><p class="funcsig">std::string::isEmpty (s: String): Boolean</p>
                                <p>Takes a single set of string events and returns a set of true or false. True if and only if the length of the string is zero.</p></li>
                                
                              <li><p class="funcsig">std::string::lastIndexOf (s1: String, s2: String): Int</p>
                                <p>Takes two sets of string events and returns the index in the first string of the last occurrence of the substring specified by the second string.</p></li>

                              <li><p class="funcsig">std::string::length (s: String): Int</p>
                                <p>Takes a single set of string events and returns a set of each string length.</p></li>

                              <li><p class="funcsig">std::string::matches (s1: String, s2: String): Boolean</p>
                                <p>Takes two sets of string events and returns true or false. True if and only if the first string matches the regular expression specified by the second string.</p></li>
							  
							    <li><p class="funcsig">std::string::numToString(ns: Numeric): String</p>
                                <p>Converts a set of numeric values to a set of strings.</p></li>

								 <li><p class="funcsig">std::string::regexMatch(s: String, regex: String): Array[String]</p>
                                <p>Takes two sets of string events and treats the latter as a set of regular expressions, returning a set of arrays of the capture groups.  Empty captures are returned as the empty set.</p></li>
								 
								 <li><p class="funcsig">std::string::split(sset: String, separator: String): Array <br> std::string::splitRegex(sset: String, regex: String): Array</p>
                                <p>These two functions split individual strings into arrays. In the former, the separator is interpreted as a literal string; in the latter, a regular expression is used to find the points to split at.</p></li>
								 
                              <li><p class="funcsig">std::string::startsWith (s1: String, s2: String): Boolean</p>
                                <p>Takes two sets of string events and returns true or false. True if and only if the first string starts with the prefix specified by the second string.</p></li>

                              <li><p class="funcsig">std::string::substring (s: String, n: Numeric): String</p>
                                <p>Takes two sets of string events and returns a new substring of the first string, beginning at the specified index.</p></li>
							  
							  <li><p class="funcsig">std::string::takeLeft(s: String, n: Numeric): String</p>
                                <p>Takes a set of string events and returns a new substring of the first string that is the first n letters from s. If n is larger than the number of letters, than s is returned.</p></li>
							  
							  <li><p class="funcsig">std::string::takeRight(s: String, n: Numeric): String</p>
                                <p>Takes a set of string events and returns a new substring of the last n letters of the string. If there are less than n letters in s, then s is returned.</p></li>

                              <li><p class="funcsig">std::string::toLowerCase (s: String): String</p>
                                <p>Takes a single set of string events and returns a set of each string with each character in lower case.</p></li>

                              <li><p class="funcsig">std::string::toUpperCase (s: String): String</p>
                                <p>Takes a single set of string events and returns a set of each string with each character in upper case.</p></li>

                              <li><p class="funcsig">std::string::trim(ss: String): String</p>
                                <p>Removes leading and trailing whitespace from the input strings.</p></li>
                            </ul>

                            <a name = "datetime"></a>
                            <h1>DateTime Function Reference</h1>
                            <ul>
                              <li><p class="funcsig">std::time::changeTimeZone (time : ISO8601, tz: String): ISO8601</p>
                                <p>Takes a set of ISO8601 strings and a set of time zone strings (of the form "+04:00") and returns a set of ISO8601 strings.</p></li>
                              
                              <li><p class="funcsig">std::time::date (time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns the date in format "yyyy-MM-dd".</p></li>
                                 
                              <li><p class="funcsig">std::time::dateHour(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the date and hour in format "yyyy-MM-dd'T'HH".</p></li>
                                 
                              <li><p class="funcsig">std::time::dateHourMinute(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the date, hour, and minute in format "yyyy-MM-dd'T'HH:mm".</p></li>
                                 
                              <li><p class="funcsig">std::time::dateHourMinuteSecond(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the date, hour, minute, and second in format "yyyy-MM-dd'T'HH:mm:ss".</p></li>
                                 
                              <li><p class="funcsig">std::time::dateHourMinuteSecondMillis(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the date, hour, minute, second, and millisecond in format "yyyy-MM-dd'T'HH:mm:ss.SSS".</p></li>
                              
                              <li><p class="funcsig">std::time::daysBetween (time1 : ISO8601, time2 : ISO8601): Int</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the days between two times.</p></li>
                              
                              <li><p class="funcsig">std::time::dayOfMonth (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the day of the month.</p></li>
                              
                              <li><p class="funcsig">std::time::dayOfWeek (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the day of the week as an integer. Monday is day 1.</p></li>
                              
                              <li><p class="funcsig">std::time::dayOfYear (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the day of the year.</p></li>
                              
                              <li><p class="funcsig">std::time::daysPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of days.</p></li>

                              <li><p class="funcsig">std::time::getMillis (time : ISO8601): Long</p>
                                <p>Takes a set of ISO8601 strings and returns a set of millisecond longs</p></li>
                                 
                              <li><p class="funcsig">std::time::hourMinute(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the hour and minute in format "HH:mm".</p></li>
                                 
                              <li><p class="funcsig">std::time::hourMinuteSecond(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the hour, minute, and second in format "HH:mm:ss".</p></li>
                              
                              <li><p class="funcsig">std::time::hourOfDay (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the hour of the day.</p></li>
                              
                              <li><p class="funcsig">std::time::hoursBetween (time1 : ISO8601, time2 : ISO8601): Long</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the hours between two times.</p></li>
                              
                              <li><p class="funcsig">std::time::hoursPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of hours.</p></li>

							<li><p class="funcsig">std::time::millisOfSecond (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the mills of the second.</p></li>
								
                              <li><p class="funcsig">std::time::maxTimeOf(d1: <em>DateTime</em>, d2: <em>DateTime</em>): <em>DateTime</em></p>
                                <p>Compares two <em>DateTime</em> values and returns the later.</p></li>
                              
                              <li><p class="funcsig">std::time::millisPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of millis.</p></li>

                              <li><p class="funcsig">std::time::millisToISO (time : Long, tz : String): ISO8601</p>
                                <p>Takes a set of long millis-since-epoch and a set of time zone strings (of the form "+04:00") and returns a set of ISO8601 strings. </p></li>
                              
							  <li><p class="funcsig">std::time::minTimeOf(d1: <em>DateTime</em>, d2: <em>DateTime</em>): <em>DateTime</em></p>
                                <p>Compares two <em>DateTime</em> values and returns the earlier.</p></li>
							  
                              <li><p class="funcsig">std::time::minuteOfHour (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the minute of the hour.</p></li>
                              
                              <li><p class="funcsig">std::time::minutesBetween (time1 : ISO8601, time2 : ISO8601): Long</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the minutes between two times.</p></li>
                                 
                              <li><p class="funcsig">std::time::minutesPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of minutes.</p></li>

                              <li><p class="funcsig">std::time::monthDay(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the month and day in format "MM-dd".</p></li>
                              
                              <li><p class="funcsig">std::time::monthOfYear (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the month of the year as an integer. January is month 1.</p></li>
                              
                              <li><p class="funcsig">std::time::monthsBetween (time1 : ISO8601, time2 : ISO8601): Int</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the months between two times.</p></li>
                              
                              <li><p class="funcsig">std::time::monthsPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of months.</p></li>

                              <li><p class="funcsig">std::time::quarter (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the quarter of year as an integer. January/February/March is quarter 1.</p></li>

                                 <li><p class="funcsig">std::time::range ({start : <em>DateTime</em>, end : <em>DateTime</em>, step : <em>Period</em>}): Array</p>
                                <p>Takes an object with start, end and step fields.  The start and end fields require a <em>DateTime</em>.  The step requires a <em>Period</em>.  A <em>Period</em> can be produced using the std::time::parse<em>Period</em>() function.  The range function returns an array of <em>DateTime</em>, inclusive of start and up to (possibly including) end, based on the interval provided in the step field.</p></li>
                              
                              <li><p class="funcsig">std::time::parseDateTime(s: String, s: String): ISO8601</p>
                                <p>Takes a set of time strings and a set of time string formats. Returns a set of ISO8601 strings. If no time zone is specified, the default is UTC.</p></li>
							 
							               <li><p class="funcsig">std::time::parseDateTimeFuzzy(s: String): ISO8601</p>
                                <p>Takes a set of time strings and makes a best effort to parse the string into a <em>DateTime</em>. If possible, returns a set of ISO8601 strings.</p></li>

                                <li><p class="funcsig">std::time::parse<em>Period</em> (s : String): <em>Period</em></p>
                                <p>Takes a string and returns a date <em>Period</em>. For information on how to construct a <em>Period</em> string, see <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">wikipedia</a></p></li>
                              
                              <li><p class="funcsig">std::time::season (time : ISO8601): String</p>
                                <p>Takes a set of ISO8601 strings and returns a set of strings. According to the solstices and equinoxes, the seasons are "fall", "winter", "spring", "summer".</p></li>
                              
                              <li><p class="funcsig">std::time::secondOfMinute (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the second of the minute.</p></li>
                              
                              <li><p class="funcsig">std::time::secondsBetween(time1 : ISO8601, time2 : ISO8601): Long</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the seconds between two times.</p></li>
                                 
                              <li><p class="funcsig">std::time::secondsPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of seconds.</p></li>

                              <li><p class="funcsig">std::time::timeWithZone(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the time and time zone in format "HH:mm:ss.SSSZZ".</p></li>
                                 
                              <li><p class="funcsig">std::time::timeWithoutZone(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the time in format "HH:mm:ss.SSS".</p></li>
                              
                              <li><p class="funcsig">std::time::timeZone (time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the time zone as a string of the form "+04:00".</p></li>
                              
                              <li><p class="funcsig">std::time::weeksBetween (time1 : ISO8601, time2 : ISO8601): Int</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the weeks between two times.</p></li>
                              
                              <li><p class="funcsig">std::time::weekOfYear (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the week of the year.</p></li>
                              
                              <li><p class="funcsig">std::time::weeksPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of weeks.</p></li>

                              <li><p class="funcsig">std::time::year (time : ISO8601): Int</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the year.</p></li>
                              
                              <li><p class="funcsig">std::time::yearsBetween (time1 : ISO8601, time2 : ISO8601): Int</p>
                                <p>Takes two sets of ISO8601 strings and returns a set of the years between two times.</p></li>
                                 
                              <li><p class="funcsig">std::time::yearDayOfYear(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the year and day of year in format "yyyy-DDD".</p></li>
                                 
                              <li><p class="funcsig">std::time::yearMonth(time : ISO8601): String</p>
                                <p>Takes a single set of ISO8601 strings and returns a set of the year and month in format "yyyy-MM".</p></li>

                              <li><p class="funcsig">std::time::yearsPlus(time : ISO8601, i : Int): String</p>
                                <p>Takes a single set of ISO8601 strings and an integer, and returns a set of ISO8601 Strings plus the specified number of years.</p></li>

                            </ul>
							
							<a name = "type"></a>
                            <h1>Type Function Reference</h1>
                            <ul>
                              <li><p class="funcsig">std::type::isArray(s : Any): boolean</p>
                                <p>Takes a single set and returns true for each event that is an Array and false for all other defined events. </p></li>
							  
							   <li><p class="funcsig">std::type::isBoolean(s : Any) : boolean</p>
                                <p>Takes a single set and returns true for each event that is a Boolean and false for all other defined events. </p></li>
							   
							    <li><p class="funcsig">std::type::isNull(s : Any): boolean</p>
                                <p>Takes a single set and returns true for each event that is a null and false for all other defined events. </p></li>
								
								 <li><p class="funcsig">std::type::isNumber(s : Any): boolean</p>
                                <p>Takes a single set and returns true for each event that is a Number and false for all other defined events. </p></li>
								 
								  <li><p class="funcsig">std::type::isObject(s : Any): boolean</p>
                                <p>Takes a single set and returns true for each event that is an Object and false for all other defined events. </p></li>
								  
								   <li><p class="funcsig">std::type::isString(s : Any): boolean</p>
                                <p>Takes a single set and returns true for each event that is an  String d false for all other defined events. </p></li>
								   
							</ul>
                          </div>
                        </div>
		    </div>
		</div>
	    </div>
        </div>
	<div class="atrib-clear-left">
	</div>
	<div id="page-footer">
	    <div id="footer-content">
		<p>Sponsored by <a href="http://www.precog.io">Precog</a></p>
	    </div>
	</div>
    <script type="text/javascript">
	piAId = '18892';
	piCId = '4171';
	
	(function() {
		function async_load(){
			var s = document.createElement('script'); s.type = 'text/javascript';
			s.src = ('https:' == document.location.protocol ? 'https://pi' : 'http://cdn') + '.pardot.com/pd.js';
			var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
		}
		if(window.attachEvent) { window.attachEvent('onload', async_load); }
		else { window.addEventListener('load', async_load, false); }
	})();
    </script>
    </body>
</html>
